/***************************************************************************
                          iso.h  -  description
                             -------------------
    begin                : Sat Apr 28 2001
    copyright            : (C) 2001 by Kevin O'Gorman
    email                : kogorman@kosmanor.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License v2, as published *
 *   by the Free Software Foundation.                                      *
 *                                                                         *
 ***************************************************************************/

/*! \file
 * \brief Declaration of class iso.
 */

#ifndef ISO_H
#define	ISO_H

#include "qval.h"

/// An isomorphism of the game arena.

/// The Qubic board has 192 isomorphisms, which may seem a lot if you're just
/// thinking about rotations and reflections.  It is; that would account for
/// only 48 isomorphisms.  The others can be generated by two additional ones.
/// The "inversion" isomorphism exchanges the extremes of each dimension for
/// the middle.  The "scramble" isomorphism exchanges the two middle positions
/// of each dimension (the two outers could be exchanged instead, but it would
/// generate the same group of isomorphisms).
///
/// The 'iso' class is used to keep track of all this.  All group of 192
/// isomorphisms is generated, and the operation table is built in 'mulcache'.
/// The actual board (and some other things) will always be viewed through
/// one of these isomorphisms (perhaps the first one, the identity).
///
/// If you don't know what an isomorphism is, here's a simple way to look at
/// it.  If you had an actual cube, you could hold it 24 ways:  there are 6
/// sides, and any one of them could be on top.  For each side, there are
/// four ways you could place the cube with that side on top.  24 combinations.
/// Whichever way you held it, the game might look different, but it would
/// really be the same game in a way.  On top of that, for each of these
/// ways of holding the cube, you could look at it in a mirror, ("apply the
/// reflection isomorphism"), and you would still have the same game, but
/// again it might look different.  The other two isomorphisms are less obvious
/// changes to the Qubic board that still leave the substance of the game
/// unchanged.

class iso {
friend class board;
private:
	int index[64];          //!< \brief The substance of the isomorphism.
	static short mulcache[192][192];    //!< \brief Multiplication table for the group.
	/// Produce the cell, indexed by 3 dimension numbers
	int& cell(int i, int j, int k){
		return index[(i*4+j)*4+k];
	}
	/// Produce the cell value, indexed by 3 dimension numbers
	int ccell(int i, int j, int k)const {
		return index[(i*4+j)*4+k];
	}
#ifdef INVERSES
	/// Every isomorphism has an inverse
	iso * _inverse;
#endif
	/// Sanity test
	int _valid;


public:
	static iso isos[200];   //!< \brief A list of isomorphisms.  There should be 192
	static int nextiso;     //!< \brief Where to put the next one.
	static void init(void); //!< \brief Initialize this iso.
#ifdef INVERSES
        /// Return the inverse of a given iso.
	iso *inverse() {
		Assert<bad_init>(NASSERT || (_valid == 34567 && _inverse != (iso*)0
                            && _inverse->_valid == 34567) );
		return _inverse;
	}
#endif
	/// Constructor for identity iso.
	iso() {
		for (int i=0; i<64; i++) {
			index[i] = i;
		}
#ifdef INVERSES
		_inverse = (iso *) 0;
#endif
		_valid = 34567;
	};
        /// Constructor for products.
	iso(const iso& a, const iso& b) {
		if (a.index[0]<0) { throw a; }
		if (b.index[0]<0) { throw b; }
		for (int i=0; i<64; i++) {
			index[i]=b.index[a.index[i]];
		}
#ifdef INVERSES
		_inverse = (iso *) 0;
#endif
		_valid = 34567;
	}
	bool isvalid() {return _valid == 34567;}    //!< \brief Is this one for real?
	/// Equality test.
	bool operator==(const iso& other) {
		for (int i=0; i<64; i++) {
			if (index[i] != other.index[i]) return false;
		}
		return true;
	}
	/// Read-only indexing is a public method.
	int val(int i, int j, int k) const {
		return ccell(i,j,k);
	}
	int val(int i)const {return index[i];}
	/// Add a new isomorphism (detects duplicates)
	static int add(const iso& a) {
		for (int i=0; i<nextiso; i++) {
			if (isos[i]==a) return i;
		}
		isos[nextiso]=a;
		nextiso++;
		if (nextiso>192) {
			cerr << "Too many isomorphisms" << endl;
			exit(1);
		}
		return nextiso-1;
	}
        /// Compose (multiply) isomorphisms
	iso operator*(const iso& right) {
		iso r;
		for (int i=0; i<64; i++) {
			r.index[i] = index[right.index[i]];
		}
		return r;
	}
	/// Multiply by isomorphism number
	int isomul(int a, int b) {
		if (mulcache[a][b] < 0) {
			mulcache[a][b] = add(isos[a] * isos[b]);
		}
		return mulcache[a][b];
	}
        /// Print all of them (debugging tool)
	static void printall(void);
	
	/// The identity isomorphism
	static iso* identity() {return &isos[0];}
	
	/// display the thing
	void show();
};

// C++ output method
ostream& operator<<(ostream&s, iso& what);

#endif
